#!/usr/bin/perl
use warnings;
my $log_id = 70000;
sub convert {
    my $ramlogs = { 'startupWarningsLog' => 'kStartupWarnings', 'rsLog' => 'kRS', 'warnings' => 'kWarnings'};
    my $expression = shift(@_);
    my $argument = shift(@_);
    my $macro = shift(@_);

    return "$expression;" if ($expression =~ /str::stream\(\)/);

    my $message = "";
    my @options;
    my @params;

    #push (@params,$log_id++);

    my $assert_value;
    if ($macro && $macro eq "FATAL") {
        my $post = $';
        $post =~ m/(.*?);/ms;
        my $first = $1;
        if ($first =~ m/assert.*\((\d+)/) {
            push(@params,$1);
        } elsif ($first =~ m/(exit|terminate)/i) {
            push(@params,0);
        } else {
            $macro = 'ERROR';
        }
    }

    my @parts = split(m/\s*\<\<\s*/s,$1 );
    shift @parts;
    #print "$fn -> $2 -> $1 -> @parts\n";
    my $attributes = [];

    # handle the magical Tee logstreamBuilder modifiers
    if ($ramlogs->{$parts[-1]}) {
        my $tag = $ramlogs->{$parts[-1]};
        my $rl = pop(@parts);
        push(@options, "logv2::LogTag::$tag");
    }

    # just toss out a terminal endl
    if (@parts && $parts[-1] =~ /\bendl$/) {
        pop(@parts);
    }

    # categorize logged things
    foreach my $part (@parts) {
        if ($part =~ /\bboolalpha$/) {
            next;
        } elsif ($part =~ /\bstd::dec$/) {
            #TODO, do we need to actually effect the formatting based on this formatting specifier?
            next;
        } elsif ($part =~ /\bendl$/) {
            $message .= "\\n";
        } elsif ($part =~ /^\s*'(.)'\s*$/s) {
            $message .= $1;
        } elsif ($part =~ /^\s*"(.*)"\s*$/s) {
            $message .= $1;
        } else {
            $attr_name = $part;
            $attr_name =~ s[^(\W|_)+][]g;
            $attr_name =~ s[(\W+|_)$][]g;
            $attr_name =~ s[(\W|_)+][_]g;
            push(@$attributes, [ $attr_name, $part ]);
            $message .= "{}";
        }
    }
    my $output = "LOGV2";
    if ($macro ne "") {
        $output .= "_";
        $output .= $macro;
    }

    if ($argument) {
        if ($argument =~ /component/i) {
            push(@options, $argument);
        } else {
            $output .= "_DEBUG";
            push(@params, "::mongo::logger::LogSeverity($argument).toInt()");
        }
    }
    if (@options) {
        push(@params, "{".join(",",@options)."}");
        $output .= "_OPTIONS";
    }
    push(@params,"\"$message\"");
    foreach (@$attributes) {
        my ($attr_name, $part) = @$_;
        push(@params, "\"$attr_name\"_attr = $part");
    }
    $output .= "(" . join(", ",@params) . ");";
    return $output;
}

sub insert_include {
    my $includes = shift(@_);
    $inc = "#include \"mongo/logv2/log.h\"";
    if (index($includes, $inc) != -1) {
        return $includes;
    }
    my @out_includes;
    my @includes = split("\n",$includes);
    my $i = scalar(@includes) -1;
    while ($i > 0 && $includes[$i] gt $inc) { $i -- }
    if ($includes[$i] eq $inc) { return join("\n",@includes) }
    return join("\n",@includes[0..$i],$inc,@includes[$i+1..$#includes]);
}

foreach my $fn (@ARGV) {
    next if $fn =~ /^#/; # skip commented out file names
    warn $fn;
    open($f, "<", $fn);
    my $data = join('',<$f>);
    $data =~ s[(\blog\(([^\)]*)\)\s+<<[^;]*);$][convert($1,$2,'')]smige;
    $data =~ s[(\bwarning\(([^\)]*)\)\s+<<[^;]*);$][convert($1,$2,'WARNING')]smige;
    $data =~ s[(\berror\(([^\)]*)\)\s+<<[^;]*);$][convert($1,$2,'ERROR')]smige;
    $data =~ s[(\bsevere\(([^\)]*)\)\s+<<[^;]*);$][convert($1,$2,'FATAL',$3)]smige;
    $data =~ s[(#include "mongo.*#include "mongo[^\n]*$)][insert_include($1)]sem;
    open($f, ">", $fn);
    $f->print($data);
}
